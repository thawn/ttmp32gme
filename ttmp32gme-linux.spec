# -*- mode: python ; coding: utf-8 -*-
"""
PyInstaller spec file for building ttmp32gme Linux standalone executable.

This creates a single executable bundle with all dependencies including:
- Python runtime
- Flask web server
- tttool binary (for GME creation)
- ffmpeg binary (for OGG conversion)
- All templates, assets, and configuration files

RESOURCE PATH RESOLUTION:
-------------------------
PyInstaller bundles files into a temporary directory at runtime. The location
is accessible via sys._MEIPASS. This differs from development mode where files
are in the source tree.

The get_resource_path() helper function in file_handler.py handles both modes:

1. Development mode (sys.frozen == False):
   - Base path: Path(__file__).parent.parent.parent → points to src/
   - Example: get_resource_path("upload.html") → src/upload.html

2. PyInstaller mode (sys.frozen == True):
   - Base path: sys._MEIPASS → points to _internal/ in bundle
   - Example: get_resource_path("upload.html") → _internal/upload.html

ADDING NEW RESOURCES:
---------------------
When adding new resource files (HTML, images, config files, etc.):

1. Add the file to the datas list below with the correct destination:
   - HTML files at root level: (str(source_path), '.')
   - Module resources: (str(source_path), 'module_name')
   - Subdirectories: (str(source_path), 'destination_dir')

2. In code, load the resource using get_resource_path():
   resource = get_resource_path("relative/path/to/resource.ext")

3. DO NOT use Path(__file__).parent or similar - use get_resource_path()

EXECUTABLES (tttool, ffmpeg):
-----------------------------
Executables are handled by get_executable_path() in file_handler.py which:
- Checks bundled lib/{platform}/ directories first
- Falls back to PATH and common locations
- Works automatically in both dev and PyInstaller modes

To add a new executable:
1. Add to binaries list below with platform-specific path
2. Use get_executable_path("executable_name") to locate it at runtime
"""

import os
import sys
from pathlib import Path

block_cipher = None

# Get the project root directory
project_root = Path(SPECPATH)
src_dir = project_root / 'src' / 'ttmp32gme'
templates_dir = project_root / 'src' / 'templates'
assets_dir = project_root / 'src' / 'assets'
lib_dir = project_root / 'lib'

# Collect all data files
datas = [
    # Templates (relative to ttmp32gme module)
    (str(templates_dir), 'templates'),
    # Assets (CSS, JS, images) - relative to ttmp32gme module
    (str(assets_dir), 'assets'),
    # OID cache (pre-generated OID images)
    (str(project_root / 'src' / 'oid_cache'), 'oid_cache'),
    # Config database
    (str(src_dir / 'config.sqlite'), 'ttmp32gme'),
    # Version file (generated by setuptools-scm)
    (str(src_dir / '_version.py'), 'ttmp32gme'),
    # Top-level HTML files (served from parent directory of ttmp32gme module)
    (str(project_root / 'src' / 'library.html'), '.'),
    (str(project_root / 'src' / 'help.html'), '.'),
    (str(project_root / 'src' / 'config.html'), '.'),
    (str(project_root / 'src' / 'upload.html'), '.'),
]

# Collect bundled binaries for Linux
binaries = []
if (lib_dir / 'mac').exists():
    # Note: On Linux, we can use Mac binaries for testing if available
    # In production, should use Linux-specific binaries
    mac_lib = lib_dir / 'mac'
    for exe in ['tttool', 'ffmpeg']:
        exe_path = mac_lib / exe
        if exe_path.exists():
            binaries.append((str(exe_path), 'lib/mac'))

    # Include required dylibs for Mac binaries
    for lib_file in mac_lib.glob('*.dylib'):
        binaries.append((str(lib_file), 'lib/mac'))

# Check for Linux-specific binaries (preferred for Linux builds)
if (lib_dir / 'linux').exists():
    linux_lib = lib_dir / 'linux'
    for exe in ['tttool', 'ffmpeg']:
        exe_path = linux_lib / exe
        if exe_path.exists():
            # Replace Mac binary with Linux version if available
            binaries = [(p, d) for p, d in binaries if not p.endswith(exe)]
            binaries.append((str(exe_path), 'lib/linux'))

# Hidden imports that PyInstaller might miss
hiddenimports = [
    'ttmp32gme',
    'ttmp32gme.ttmp32gme',
    'ttmp32gme.build',
    'ttmp32gme.build.file_handler',
    'ttmp32gme.db_handler',
    'ttmp32gme.tttool_handler',
    'ttmp32gme.print_handler',
    'flask',
    'werkzeug',
    'jinja2',
    'mutagen',
    'PIL',
    'pydantic',
    'packaging',
]

a = Analysis(
    ['src/ttmp32gme/ttmp32gme.py'],
    pathex=[str(project_root / 'src')],
    binaries=binaries,
    datas=datas,
    hiddenimports=hiddenimports,
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[
        'tkinter',
        'unittest',
        'test',
        'tests',
    ],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='ttmp32gme',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=True,  # Keep console for logging output
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='ttmp32gme',
)
