name: Build and Release Executables

on:
  release:
    types: [published]
  pull_request:
    paths:
      - 'src/**'
      - 'resources/**'
      - 'ttmp32gme-*.spec'
      - 'pyproject.toml'
      - '.github/workflows/release-executables.yml'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g., v2.0.0)'
        required: true

permissions:
  contents: write

jobs:
  build-windows:
    name: Build Windows Executable
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[build]"

      - name: Download tttool for Windows
        run: |
          $TTTOOL_VERSION = "1.8.1"
          Write-Host "Downloading tttool version $TTTOOL_VERSION for Windows"

          # Create lib/win directory if it doesn't exist
          New-Item -ItemType Directory -Force -Path lib/win

          # Download tttool to temp directory
          $tempDir = New-Item -ItemType Directory -Path (Join-Path $env:TEMP "tttool-temp-$(Get-Random)")
          $url = "https://github.com/entropia/tip-toi-reveng/releases/download/${TTTOOL_VERSION}/tttool-${TTTOOL_VERSION}.zip"
          $zipPath = Join-Path $tempDir "tttool.zip"
          Invoke-WebRequest -Uri $url -OutFile $zipPath

          # Extract to temp directory and move binary
          Expand-Archive -Path $zipPath -DestinationPath $tempDir -Force
          Move-Item -Path (Join-Path $tempDir "tttool.exe") -Destination lib/win/tttool.exe -Force

          # Cleanup temp directory
          Remove-Item -Recurse -Force $tempDir

          # Verify
          lib/win/tttool.exe --help

      - name: Download ffmpeg for Windows
        run: |
          Write-Host "Downloading ffmpeg for Windows"

          # Function to download and extract ffmpeg with timeout
          function Install-Ffmpeg {
            param([int]$TimeoutSeconds = 60)

            $tempDir = New-Item -ItemType Directory -Path (Join-Path $env:TEMP "ffmpeg-temp-$(Get-Random)")
            $url = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip"
            $zipPath = Join-Path $tempDir "ffmpeg.zip"

            try {
              # Download with timeout
              $job = Start-Job -ScriptBlock {
                param($url, $zipPath)
                Invoke-WebRequest -Uri $url -OutFile $zipPath
              } -ArgumentList $url, $zipPath

              if (Wait-Job -Job $job -Timeout $TimeoutSeconds) {
                Receive-Job -Job $job
                Remove-Job -Job $job -Force

                # Extract with timeout
                $extractJob = Start-Job -ScriptBlock {
                  param($zipPath, $tempDir)
                  Expand-Archive -Path $zipPath -DestinationPath $tempDir -Force
                } -ArgumentList $zipPath, $tempDir

                if (Wait-Job -Job $extractJob -Timeout $TimeoutSeconds) {
                  Receive-Job -Job $extractJob
                  Remove-Job -Job $extractJob -Force

                  # Find and move ffmpeg.exe
                  $ffmpegDir = Get-ChildItem -Path $tempDir -Directory -Filter "ffmpeg-*" | Select-Object -First 1
                  Move-Item -Path (Join-Path $ffmpegDir.FullName "bin/ffmpeg.exe") -Destination lib/win/ffmpeg.exe -Force
                  return $true
                } else {
                  Stop-Job -Job $extractJob
                  Remove-Job -Job $extractJob -Force
                  return $false
                }
              } else {
                Stop-Job -Job $job
                Remove-Job -Job $job -Force
                return $false
              }
            } finally {
              # Cleanup temp directory
              if (Test-Path $tempDir) {
                Remove-Item -Recurse -Force $tempDir -ErrorAction SilentlyContinue
              }
            }
          }

          # Try first attempt
          Write-Host "Attempting to download ffmpeg (attempt 1)..."
          if (Install-Ffmpeg -TimeoutSeconds 60) {
            Write-Host "ffmpeg installed successfully on first attempt"
          } else {
            Write-Host "First attempt failed or timed out, retrying..."
            # Clean up any partial downloads
            Remove-Item -Path lib/win/ffmpeg.exe -Force -ErrorAction SilentlyContinue

            # Retry
            Write-Host "Attempting to download ffmpeg (attempt 2)..."
            if (Install-Ffmpeg -TimeoutSeconds 60) {
              Write-Host "ffmpeg installed successfully on second attempt"
            } else {
              Write-Error "Error: ffmpeg installation failed after 2 attempts"
              exit 1
            }
          }

          # Verify
          lib/win/ffmpeg.exe -version

      - name: Build Windows executable with PyInstaller
        run: |
          pyinstaller ttmp32gme-windows.spec --clean

      - name: Upload Windows executable
        uses: actions/upload-artifact@v4
        with:
          name: ttmp32gme-windows
          path: dist/ttmp32gme
          retention-days: 30

      - name: Create ZIP archive for release
        if: github.event_name == 'release'
        run: |
          cd dist
          Compress-Archive -Path ttmp32gme -DestinationPath ttmp32gme-windows.zip

      - name: Upload to release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: dist/ttmp32gme-windows.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-macos:
    name: Build macOS Executable
    runs-on: macos-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[build]"

      - name: Download tttool for macOS
        run: |
          TTTOOL_VERSION="1.11"
          echo "Downloading tttool version $TTTOOL_VERSION for macOS"

          # Create lib/mac directory if it doesn't exist
          mkdir -p lib/mac

          # Create temp directory for extraction
          TEMP_DIR=$(mktemp -d)
          cd "$TEMP_DIR"

          # Download and extract tttool
          wget -q "https://github.com/entropia/tip-toi-reveng/releases/download/${TTTOOL_VERSION}/tttool-${TTTOOL_VERSION}.zip"
          unzip -q "tttool-${TTTOOL_VERSION}.zip"
          cd tttool-1.11/osx

          # Move binary and dynamic libraries to lib/mac
          chmod +x tttool
          mv tttool "$GITHUB_WORKSPACE/lib/mac/tttool"

          # Copy all .dylib files if they exist
          if ls *.dylib 1> /dev/null 2>&1; then
            mv *.dylib "$GITHUB_WORKSPACE/lib/mac/"
          fi

          # Cleanup temp directory - change permissions first to ensure deletion succeeds
          cd "$GITHUB_WORKSPACE"
          chmod -R u+w "$TEMP_DIR" || true
          rm -rf "$TEMP_DIR"

          # Verify - check architecture and try to run
          lib/mac/tttool --help || {
            echo "Failed to execute tttool"
            echo "Exit code: $?"
            echo "Checking otool dependencies:"
            otool -L lib/mac/tttool || echo "otool failed"
            exit 1
          }

      - name: Download ffmpeg for macOS
        run: |
          echo "Downloading ffmpeg for macOS"

          # Create temp directory for extraction
          TEMP_DIR=$(mktemp -d)
          cd "$TEMP_DIR"

          # Try to download and extract ffmpeg with 60 second timeout
          if timeout 60 wget -q "https://evermeet.cx/ffmpeg/getrelease/ffmpeg/zip" -O ffmpeg.zip && \
             timeout 60 unzip -q ffmpeg.zip; then
            # Move binary to lib/mac
            chmod +x ffmpeg
            mv ffmpeg "$GITHUB_WORKSPACE/lib/mac/ffmpeg"
            echo "ffmpeg downloaded successfully on first attempt"
          else
            echo "First attempt failed or timed out, retrying..."
            # Clean up any partial downloads
            cd "$GITHUB_WORKSPACE"
            chmod -R u+w "$TEMP_DIR" || true
            rm -rf "$TEMP_DIR"
            # Create new temp directory
            TEMP_DIR=$(mktemp -d)
            cd "$TEMP_DIR"
            # Retry with 60 second timeout
            if timeout 60 wget -q "https://evermeet.cx/ffmpeg/getrelease/ffmpeg/zip" -O ffmpeg.zip && \
               timeout 60 unzip -q ffmpeg.zip; then
              # Move binary to lib/mac
              chmod +x ffmpeg
              mv ffmpeg "$GITHUB_WORKSPACE/lib/mac/ffmpeg"
              echo "ffmpeg downloaded successfully on second attempt"
            else
              echo "Error: ffmpeg installation failed after 2 attempts"
              exit 1
            fi
          fi

          # Cleanup temp directory - change permissions first to ensure deletion succeeds
          cd "$GITHUB_WORKSPACE"
          chmod -R u+w "$TEMP_DIR" || true
          rm -rf "$TEMP_DIR"

          # Verify
          lib/mac/ffmpeg -version

      - name: Build macOS executable with PyInstaller
        run: |
          pyinstaller ttmp32gme-macos.spec --clean

      - name: Prepare macOS artifact
        run: |
          # Create a clean artifact directory with the .app bundle
          mkdir -p artifact-macos
          cp -R dist/ttmp32gme.app artifact-macos/

      - name: Upload macOS executable
        uses: actions/upload-artifact@v4
        with:
          name: ttmp32gme-macos
          path: artifact-macos/
          retention-days: 30

      - name: Create ZIP archive for release
        if: github.event_name == 'release'
        run: |
          cd dist
          # For now, create a ZIP. Later we can create a proper DMG
          zip -r ttmp32gme-macos.zip ttmp32gme.app

      - name: Upload to release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: dist/ttmp32gme-macos.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
